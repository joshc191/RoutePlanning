<!DOCTYPE HTML>
<html>
<head>
  <link href='https://api.mapbox.com/mapbox-gl-js/v2.1.1/mapbox-gl.css' rel='stylesheet' />
  <script src='https://api.mapbox.com/mapbox-gl-js/v2.1.1/mapbox-gl.js'></script>
  <script src='https://api.mapbox.com/mapbox.js/plugins/turf/v3.0.11/turf.min.js'></script>

  <script src="https://api.tiles.mapbox.com/mapbox-gl-js/v2.1.1/mapbox-gl.js"></script>
  <link href="https://api.tiles.mapbox.com/mapbox-gl-js/v2.1.1/mapbox-gl.css" rel="stylesheet" />

  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.2.1/mapbox-gl-draw.js"></script>
  <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.2.1/mapbox-gl-draw.css" type="text/css">

  <!--Bootstrap-->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">

  <!--CSS sheet-->
  <!-- <link rel="stylesheet" href="styles.css"> -->
  <link rel="stylesheet" href="{{ url_for('static', filename='styles/styles.css') }}">

  <!-- Import jQuery -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

  <title>ENGO 551 Final Project</title>
</head>

<body>
  <!--navigation bar-->
  <nav class="navbar navbar-expand-lg navbar-light" style="background-color: #e3f2fd;">
    <a class="navbar-brand" href="/">
      <!-- <img src="delivery.png" height="60" width="60" alt=""> -->
      <img src="{{ url_for('static', filename='delivery.png') }}" height="60" width="60" alt="">
      Route Planning for Mobile Grocery Store
    </a>
  </nav>
  
  <div class="info-box">
    <div id="directions"></div>
  </div>

  <div class="row">
    <div class="col-md-3">
      <br/>
      <h3>Efficient Route Planning from Uploaded Addresses</h3>
      <p>Please upload a csv file of list of addresses to accomodate on the trip</p>
      <P>The page can be toggled for the list of addresses and the location of the stops and its route</P>
      <br/>

      <!-- Create form for address+stop input -->
      <form id="form">
        <div>
          <label for="addresslist">Upload your address list (csv):</label>
          <input type="file" id="addresses" name="addresslist" accept=".csv"><br><br>
        </div>
        <div>
        <label for="stopnum">Number of stops:</label>
        <input type="range" min="2" max="20" value="5" id="stopnum" name="stopnum"
      	 step="1" oninput="outputUpdate(value)">
        <output for="stopnum" id="stopnum_out">5</output><br><br>
        </div>
        <button type='button' id='submit1'>submit</button>
      </form>
      <font color="red">
      <div>
        <span id="AddressFindError"></span>
      </div>
    </font>

    </div>


    <!-- Add map container element -->
    <div class="col-md-9">
      <div id="map"></div>
    </div>
  </div>
 

  <script>
    // Create map container
    mapboxgl.accessToken = 'pk.eyJ1IjoiY2hyaXNrY2NobyIsImEiOiJja200ZGE3YzEwM2hhMm9wbThweHVpbmdnIn0.WK32LPKYrtmevgs6emkIrQ';
    var map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/light-v10',
      center: [-114.0719,51.0447],
      zoom: 12
    });

    //-------------Define Functions------------------//

    // Function to add label for the number of step slider
    function outputUpdate(stopnum) {
    	document.querySelector('#stopnum_out').value = stopnum;
    }

    // Function which reads file as text when called.
    async function readFile() {
      document.getElementById("AddressFindError").innerHTML = '';  // Clear error log

      var reader = new FileReader();
      var inputform = document.getElementById("addresses");
      reader.onload = function () {
        let addressliststr = reader.result;
        var addresslist = addressliststr.split("\n");

        // Remove blank spaces from csv
        addresslist = addresslist.filter(function(entry) { return entry.trim() != ''; });

        var coords = getAddress(addresslist);
      };
      // start reading the file. When it is done, calls the onload event defined above.
      reader.readAsText(inputform.files[0]);
    };

    // Function to get coordinates of each address from OpenCalgary API
    function getlink (address) {
      let link = "https://data.calgary.ca/resource/9zvu-p8uz.geojson?$q=";
      link+= "'";
      link+= address;
      link+="'";
      return link;
    };

    async function getAddress(addresslist) {
      var AdjFeatCollec = {type: 'FeatureCollection',features: []};
      var bigdata = {type: 'FeatureCollection',features: []};

      // Add individual geojson urls to a single feat collection
      for (i = 0; i < addresslist.length;i++) {
        url4edit = getlink(addresslist[i]);

        const response = await fetch(url4edit);
        var data1 = await response.json();

        if (i==0)  { // Check if the first address is a grocery store
          checkGrocery(addresslist[i]); // If not grocery store, then give warning message.
        }

        if (typeof data1.features[0] === 'undefined') {  // Check if address is found in the database
          error = "Error: Address " + i + " (" + addresslist[i] + ") was excluded because its coordinates could not be found."
          document.getElementById("AddressFindError").innerHTML += error + '<br>';
        } else {
          bigdata.features.push(data1.features[0]);
        }
      }

      var mycount = 0;
      for (i = 0; i < bigdata.features.length;i++) {//Adjusted feat collection to work with turf
        mycount= mycount+1;

        var feat = {
          'type': 'Feature',
          'properties': {
            'Name': bigdata.features[i].properties.street_name,
            'Address': bigdata.features[i].properties.address
          },
          'geometry': {
            'type': 'Point',
            'coordinates': [parseFloat(bigdata.features[i].properties.longitude),
            parseFloat(bigdata.features[i].properties.latitude)]
          }
        };
        AdjFeatCollec.features.push(feat);
      };

      // Add addresses to map as markers
      if (!map.hasImage('custom-marker')) { // If the image hasn't been added yet
        map.loadImage('https://docs.mapbox.com/mapbox-gl-js/assets/custom_marker.png', function (error, image) {
          if (error) throw error;
          // Add an image to use as a custom marker
          map.addImage('custom-marker', image);
          // Add a GeoJSON source with 2 points
        });
      }

      // Remove existing layer
      if (typeof map.getLayer('points') !== 'undefined')  {
        map.removeLayer('points').removeSource('points');
      }

      // Add data source
      map.addSource('points', {
        'type': 'geojson',
        'data': AdjFeatCollec,
        'tolerance': 0  // Lower number means icon stays when zoomed out
      });

      // Add a symbol layer
      map.addLayer({
        'id': 'points',
        'type': 'symbol',
        'source': 'points',
        'layout': {
          'icon-image': 'custom-marker',
          'icon-size': 0.35,
          'icon-allow-overlap': true,
          // get the title name from the source's "title" property
          'text-field': ['get', 'title'],
          'text-font': [
          'Open Sans Semibold',
          'Arial Unicode MS Bold'],
          'text-offset': [0, 1.25],
          'text-anchor': 'top'
        }
      });

      // Remove existing popups
      if (typeof popup !== 'undefined')  {
        popup.remove();
      }
      // Add popups
      var popup = new mapboxgl.Popup();
      map.on('click', 'points', function(e) {
        var features = map.queryRenderedFeatures(e.point, { layers: ['points'] });

        if (!features.length) {
          popup.remove();
          return;
        }
        var feature = features[0];
        var coordinates = feature.geometry.coordinates;

        // Ensure that if the map is zoomed out such that multiple
        // copies of the feature are visible, the popup appears
        // over the copy being pointed to.
        while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
          coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
        }

        popup.setLngLat(coordinates)
          .setHTML(feature.properties.Address)
          .addTo(map);
      });

      // Change the cursor to a pointer when the mouse is over the points layer.
      map.on('mouseenter', 'points', function () {
        map.getCanvas().style.cursor = 'pointer';
      });

      // Change it back to a pointer when it leaves.
      map.on('mouseleave', 'points', function () {
        map.getCanvas().style.cursor = '';
      });

      // Proceed with clustering addresses
      clusterStops(AdjFeatCollec);
    };

    // Check if address is a grocery store
    async function checkGrocery(address)  {
      var base_url = 'https://data.calgary.ca/resource/vdjc-pybd.json?$where=licensetypes=\'FOOD SERVICE - PREMISES\'&address =\'' + address + '\'';
      let response = await fetch(url4edit);
      var data1 = await response.json();
      if (typeof data1[0] === 'undefined')  {
        var warning = "Warning: The first address submitted doesn\'t seem to be a grocery store. Ensure your first address is the truck's starting location."
        document.getElementById("AddressFindError").innerHTML += warning + '<br>';
      }
    }

    // Cluster addresses into stops using K-means Clustering
    async function clusterStops(AdjFeatCollec) {
      var points = AdjFeatCollec;
      points.features.shift();
      console.log(points);
      var stopnum = document.getElementById("stopnum").value;   // Get number of stops

      if (stopnum > points.features.length) {
        error = "Error: Number of stops exceeds number of addresses. Changing number of stops to match number of addresses. "
        document.getElementById("AddressFindError").innerHTML += error + '<br>';
        // Turf kmeans function automatically limits number of clusters. No need to change manually.
      }

      var options = {numberOfClusters: stopnum};
      var clustered = turf.clustersKmeans(points, options);

      var total = 0 //counting the number of clusters, remove once user input added
      turf.clusterEach(clustered, 'cluster', function () {
        total++;
      });

      var values = {type: 'FeatureCollection',features: []};
      var stops = [];
      for (i = 0; i < total;i++) {//Adding individual geojson urls to  a single feat collection
        var cluster = turf.getCluster(clustered, {cluster: i});
        var feat = {
          'type': 'Feature',
          'properties': {
            'Name': cluster.features[0].properties.cluster //which cluster
          },
          'geometry': {
            'type': 'Point',
            'coordinates': cluster.features[0].properties.centroid //cluster coordinates
          }
        };
        values.features.push(feat);
        stops.push(cluster.features[0].properties.centroid);
      }

      // Add addresses to map as markers
      if (!map.hasImage('custom-marker')) { // If the image hasn't been added yet
        map.loadImage('https://cdn0.iconfinder.com/data/icons/small-n-flat/24/678111-map-marker-512.png', function (error, image) {
          if (error) throw error;
          // Add an image to use as a custom marker
          map.addImage('custom-mark', image);
        });
      }

      // Remove existing layer
      if (typeof map.getLayer('point') !== 'undefined')  {
        map.removeLayer('point').removeSource('point');
      }

      map.addSource('point', {
        'type': 'geojson',
        'data': values,
        'tolerance': 0
      });

        // Add a symbol layer
      map.addLayer({
        'id': 'point',
        'type': 'symbol',
        'source': 'point',
        'layout': {
          'icon-image': 'custom-mark',
          'icon-size': 0.05,
          'icon-allow-overlap': true,
          // get the title name from the source's "title" property
          'text-field': ['get', 'title'],
          'text-font': [
          'Open Sans Semibold',
          'Arial Unicode MS Bold'
          ],
          'text-offset': [0, 1.25],
          'text-anchor': 'top'
        }
      });

      // Add first address to start of stops (i.e. where the truck starts the day)
      stops.unshift(points.features[0].geometry.coordinates);

      // Re-order stops into their optimal order using travelling salesman solution
      var response2 = await fetch("/reorder_stops/" + stops.toString());
      stops_json = await response2.json();

      stops_str = stops_json["coordinates"];
      stops_str = stops_str.replace(/\[/g, '');
      stops_str = stops_str.replace(/\]/g, '');
      stops_str = stops_str.split("\n");

      var stops_ord = [];
      for (i = 0; i < stops_str.length; i++) {  //Adding coordinates to array
        let coord_i = stops_str[i].split("   ");
        let coord = [parseFloat(coord_i[0]), parseFloat(coord_i[1])];
        stops_ord.push(coord);
      }
      // addRoute2(stops_ord);
      updateRoute(stops_ord);
    }

    //function to format the coordinates so it can be used in map matching query
    function updateRoute(stops_ord) {
      //set profile
      var profile = "driving";
      //get coords that were drawn (need to replace with coordinates)
      var data = stops_ord;
      //Format the new coordinates
      var newCoords = data.join(';');
      //set radius for each coordinate pair as 25 meters
      var radius = [];
      data.forEach(element => {
        radius.push(600);
      });
      getMatch(newCoords,radius,profile)
    }

    function getMatch(coordinates, radius, profile) {
      var radiuses = radius.join(';');
      var query = 'https://api.mapbox.com/directions/v5/mapbox/' + profile + '/' + coordinates + '?geometries=geojson&radiuses=' + radiuses + '&steps=true&access_token=' + mapboxgl.accessToken;
      console.log(query);

      $.ajax({
        method: 'GET',
        url: query
      }).done(function(data) {
        //get coordinates from response
        var coords = data.routes[0].geometry;
        addRoute(coords);
        getInstructions(data.routes[0]);
      });
    }

    function addRoute(coords) {
      if (typeof map.getLayer('route') !== 'undefined')  {
        map.removeLayer('route').removeSource('route');
      }
      map.addLayer({
        "id": "route",
        "type": "line",
        "source": {
          "type": "geojson",
          "data": {
            "type": "Feature",
            "properties": {},
            "geometry": coords
          }
        },
        "layout": {
          "line-join": "round",
          "line-cap": "round"
        },
        "paint": {
          "line-color": "#03AA46",
          "line-width": 8,
          "line-opacity": 0.8
        }
      });


    }

    function getInstructions(data) {
      var directions = document.getElementById('directions');
      var legs = data.legs;
      var tripDirections = [];
      for (var i = 0; i < legs.length; i++) {
        var steps = legs[i].steps;
        for (var j = 0; j < steps.length; j++) {
          tripDirections.push('<br><li>'+steps[j].maneuver.instruction) + '</li>';
        }
      }
      directions.innerHTML = '<br><h2>Trip duration: ' + Math.floor(data.duration/60) + ' min.</h2>' + tripDirections;
    }
    //------------End function definition-------------//

    // Get file containing list of addresses
    var submit = document.getElementById("submit1");

    // Read file by calling readFile
    submit.addEventListener('click', readFile);
    </script>
  </body>
  </html>

